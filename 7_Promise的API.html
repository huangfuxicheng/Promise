<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>7_Promise的API</title>
</head>
<body>
<script>
    //1.Promise构造函数 new Promise(executor){}
    //   executor函数：是同步执行的 (resolve,reject)=>{}
    //      resolve函数：调用resolve将Promise实例内部状态改为成功(fulfilled)。
    //      reject函数：调用reject将Promise实例内部状态改为失败(rejected)。
    //      说明：executor函数会在Promise内部立即同步调用，异步代码放在executor函数中。
    // 2.Promise.prototype.then方法：Promise实例.then(onFulfilled,onRejected)
    //     onFulfilled:成功的回调函数(value)=>{}
    //     onRejected:失败的回调函数(reason)=>{}
    //     特别注意（难点）：then方法会返回一个新的Promise实例对象
    // 3.Promise.prototype,catch方法：Promise实例.catch(onRejected)
    //     onRejected:失败的回调函数(reason)=>{
    //       说明：catch方法是then方法的语法糖，相当于：then(undefined,onRejected)
    //4.Promise.resolve方法：Promise.resolve(value)
    //      说明：用于快速返回一个状态为fulfilled的Promise实例对象
    //5.Promise.reject方法：Promise.reject方法(reason)
    //     说明：用于快速返回一个状态为rejected的Promise实例对象
    //6.Promise.al1方法：Promise.all(promiseArr)
    //     promiseArr:包含n个Promise实例的数组
    //     说明：返回一个新的Promise实例，只有所有的promise都成功才成功，只要有一个失败了就直接失败。
    // 7.Promise,race方法：Promise,race(promiseArr)
    //     promiseArr:包含n个Promise实例的数组
    //     说明：返回一个新的Promise实例，成功还是很失败？以最先出结果的promise为准。
    const p = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(100)
        }, 1000)
    })
    const x = p.then(value => console.log(value),
        reason => console.log(reason))
    console.log(x)
</script>
</body>
</html>